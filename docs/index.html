<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DeSmell — Smell Detection Catalog</title>
  <style>
    :root{
      --bg:#f8fafc;
      --bg-card:#ffffff;
      --text:#1e293b;
      --muted:#64748b;
      --border:#e2e8f0;
      --codebg:#f1f5f9;
      --codeborder:#cbd5e1;
      --link:#3b82f6;
      --link-hover:#2563eb;
      --h:#0f172a;
      --chip-arch:#fef3c7;
      --chip-arch-text:#92400e;
      --chip-recomp:#dbeafe;
      --chip-recomp-text:#1e40af;
      --chip-state:#fce7f3;
      --chip-state-text:#9f1239;
      --chip-api:#e0e7ff;
      --chip-api-text:#3730a3;
      --success:#10b981;
      --warning:#f59e0b;
      --error:#ef4444;
      --info:#3b82f6;
      --shadow-sm:0 1px 2px 0 rgba(0,0,0,0.05);
      --shadow:0 1px 3px 0 rgba(0,0,0,0.1),0 1px 2px 0 rgba(0,0,0,0.06);
      --shadow-md:0 4px 6px -1px rgba(0,0,0,0.1),0 2px 4px -1px rgba(0,0,0,0.06);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .wrap{max-width:1200px; margin:0 auto; padding:32px 20px 64px;}
    header{
      padding:32px 0;
      border-bottom:2px solid var(--border);
      margin-bottom:32px;
      background:var(--bg-card);
      padding-left:20px;
      padding-right:20px;
      margin-left:-20px;
      margin-right:-20px;
      border-radius:0;
    }
    h1{
      margin:0 0 12px 0;
      font-size:36px;
      letter-spacing:-0.02em;
      color:var(--h);
      font-weight:700;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:17px;
      line-height:1.5;
    }
    a{color:var(--link); text-decoration:none; transition:color 0.2s}
    a:hover{color:var(--link-hover); text-decoration:underline}
    .grid{
      display:grid;
      grid-template-columns: 280px 1fr;
      gap:32px;
      align-items:start;
    }
    @media (max-width: 1000px){
      .grid{grid-template-columns:1fr}
    }
    nav{
      border:1px solid var(--border);
      border-radius:12px;
      padding:20px;
      background:var(--bg-card);
      position:sticky;
      top:20px;
      box-shadow:var(--shadow-sm);
    }
    nav h2{
      margin:0 0 16px 0;
      font-size:18px;
      color:var(--h);
      font-weight:600;
    }
    nav ol, nav ul{
      margin:8px 0 0 0;
      padding:0 0 0 20px;
    }
    nav li{margin:6px 0; line-height:1.5}
    nav .lvl2{margin-top:8px; margin-left:8px}
    nav .lvl2 li{margin:4px 0}
    main section{
      padding:24px;
      border:1px solid var(--border);
      border-radius:12px;
      margin-bottom:24px;
      background:var(--bg-card);
      box-shadow:var(--shadow-sm);
      transition:box-shadow 0.2s;
    }
    main section:hover{
      box-shadow:var(--shadow);
    }
    main h2{
      margin:0 0 16px 0;
      font-size:24px;
      color:var(--h);
      letter-spacing:-0.01em;
      font-weight:700;
      padding-bottom:12px;
      border-bottom:2px solid var(--border);
    }
    main h3{
      margin:20px 0 10px 0;
      font-size:18px;
      color:var(--h);
      font-weight:600;
    }
    .meta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin:0 0 20px 0;
      align-items:center;
    }
    .chip{
      display:inline-block;
      padding:6px 14px;
      border-radius:20px;
      font-size:13px;
      font-weight:600;
      border:none;
    }
    .chip-arch{
      background:var(--chip-arch);
      color:var(--chip-arch-text);
    }
    .chip-recomp{
      background:var(--chip-recomp);
      color:var(--chip-recomp-text);
    }
    .chip-state{
      background:var(--chip-state);
      color:var(--chip-state-text);
    }
    .chip-api{
      background:var(--chip-api);
      color:var(--chip-api-text);
    }
    .detector-id{
      font-family:ui-monospace, monospace;
      font-size:13px;
      color:var(--muted);
      background:var(--codebg);
      padding:4px 8px;
      border-radius:4px;
    }
    .kvs{
      width:100%;
      border-collapse:collapse;
      margin:16px 0 0 0;
      background:var(--bg-card);
    }
    .kvs th, .kvs td{
      border-top:1px solid var(--border);
      padding:14px 16px;
      vertical-align:top;
    }
    .kvs th{
      width:200px;
      color:var(--h);
      font-weight:600;
      text-align:left;
      background:var(--codebg);
      font-size:14px;
    }
    .kvs td{
      font-size:15px;
      line-height:1.6;
    }
    .kvs ul, .kvs ol{
      margin:8px 0;
      padding-left:24px;
    }
    .kvs li{
      margin:6px 0;
      line-height:1.6;
    }
    .code{
      background:var(--codebg);
      border:1px solid var(--codeborder);
      border-radius:8px;
      padding:14px 16px;
      overflow-x:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:14px;
      line-height:1.6;
      margin:8px 0;
      white-space:pre-wrap;
      word-wrap:break-word;
      tab-size:4;
    }
    .code-block{
      margin:12px 0;
    }
    .bad-example{
      border-left:4px solid var(--error);
      background:#fef2f2;
    }
    .good-example{
      border-left:4px solid var(--success);
      background:#f0fdf4;
    }
    .example-label{
      font-size:12px;
      font-weight:600;
      text-transform:uppercase;
      margin-bottom:6px;
      display:block;
    }
    .bad-example .example-label{
      color:var(--error);
    }
    .good-example .example-label{
      color:var(--success);
    }
    .note{
      border-left:4px solid var(--info);
      background:#eff6ff;
      padding:14px 16px;
      border-radius:8px;
      margin:16px 0 0 0;
      color:#1e3a8a;
    }
    .note strong{
      color:#1e40af;
    }
    .warning{
      border-left:4px solid var(--warning);
      background:#fffbeb;
      padding:14px 16px;
      border-radius:8px;
      margin:16px 0 0 0;
      color:#92400e;
    }
    .summary{
      border:2px solid var(--border);
      border-radius:12px;
      padding:24px;
      background:var(--bg-card);
      margin:0 0 32px 0;
      box-shadow:var(--shadow-sm);
    }
    .summary h2{
      margin:0 0 20px 0;
      font-size:22px;
      font-weight:700;
      border-bottom:2px solid var(--border);
      padding-bottom:12px;
    }
    .summary table{
      width:100%;
      border-collapse:collapse;
      font-size:14px;
    }
    .summary thead{
      background:var(--codebg);
    }
    .summary th,.summary td{
      border:1px solid var(--border);
      padding:12px 10px;
      text-align:left;
      vertical-align:top;
    }
    .summary th{
      color:var(--h);
      font-weight:700;
      font-size:13px;
      text-transform:uppercase;
      letter-spacing:0.5px;
    }
    .summary td{
      font-size:13px;
      line-height:1.5;
    }
    .summary tr:hover{
      background:var(--codebg);
    }
    .formula{
      background:var(--codebg);
      border:1px solid var(--codeborder);
      border-radius:8px;
      padding:16px;
      margin:12px 0;
      font-family:ui-monospace, monospace;
      font-size:15px;
      text-align:center;
      font-weight:600;
      color:var(--h);
    }
    .threshold-box{
      background:var(--codebg);
      border-left:4px solid var(--warning);
      padding:12px 16px;
      border-radius:4px;
      margin:12px 0;
    }
    .threshold-box strong{
      color:var(--warning);
      display:block;
      margin-bottom:4px;
    }
    footer{
      margin-top:40px;
      padding-top:24px;
      border-top:2px solid var(--border);
      color:var(--muted);
      font-size:14px;
      text-align:center;
    }
    .quick-ref{
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(250px, 1fr));
      gap:16px;
      margin:24px 0;
    }
    .quick-ref-card{
      background:var(--codebg);
      border:1px solid var(--border);
      border-radius:8px;
      padding:16px;
    }
    .quick-ref-card h4{
      margin:0 0 8px 0;
      font-size:15px;
      color:var(--h);
      font-weight:600;
    }
    .quick-ref-card p{
      margin:0;
      font-size:13px;
      color:var(--muted);
      line-height:1.5;
    }
    .category-header{
      display:flex;
      align-items:center;
      gap:12px;
      margin:32px 0 16px 0;
      padding-bottom:12px;
      border-bottom:2px solid var(--border);
    }
    .category-header h3{
      margin:0;
      font-size:20px;
      font-weight:700;
      color:var(--h);
    }
    .badge{
      display:inline-block;
      padding:4px 10px;
      border-radius:12px;
      font-size:11px;
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:0.5px;
    }
    .badge-high{
      background:#fee2e2;
      color:#991b1b;
    }
    .badge-medium{
      background:#fef3c7;
      color:#92400e;
    }
    .badge-low{
      background:#dbeafe;
      color:#1e40af;
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>DeSmell — Smell Detection Catalog</h1>
    <p class="subtitle">
      Complete reference guide for all 14 presentation-layer code smells detected by DeSmell in Jetpack Compose applications.
      Each smell includes detection rules, metrics, thresholds, and practical examples to help developers write cleaner, more maintainable Compose code.
    </p>
  </header>

  <div class="grid">
    <nav aria-label="Table of Contents">
      <h2>Contents</h2>
      <ol>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#catalog">Quick Reference</a></li>
        <li>
          <a href="#smells">Smell Catalog</a>
          <ol class="lvl2">
            <li><a href="#cfc">CFC</a></li>
            <li><a href="#constants">Constants</a></li>
            <li><a href="#sed">SED</a></li>
            <li><a href="#liu">LIU</a></li>
            <li><a href="#multi-flow">Multiple Flows</a></li>
            <li><a href="#ms-cond">MutableState in Conditions</a></li>
            <li><a href="#ms-mutation">State Mutation</a></li>
            <li><a href="#remember-saveable">Non-Savable Type</a></li>
            <li><a href="#rus-constant">rememberUpdatedState</a></li>
            <li><a href="#reused-key">Reused Key</a></li>
            <li><a href="#sec">SEC</a></li>
            <li><a href="#slot-count">Slot Count</a></li>
            <li><a href="#reactive-pass-through">Reactive State Pass-Through</a></li>
            <li><a href="#non-snapshot-collection">Non-Snapshot-Aware Collections in State</a></li>
          </ol>
        </li>
        <li><a href="#appendix-metrics">Metrics Reference</a></li>
      </ol>
    </nav>

    <main>
      <section id="overview">
        <h2>Overview</h2>
        <div class="meta">
          <span class="chip chip-arch">Repository-ready</span>
          <span class="chip chip-recomp">Detector-aligned</span>
          <span class="chip chip-state">Metric-based</span>
        </div>

        <p>
          <strong>DeSmell</strong> is a static analysis tool that detects code smells in Jetpack Compose presentation layers.
          It analyzes Kotlin code using AST/UAST analysis to identify 14 distinct types of code smells that violate
          declarative UI principles, reduce maintainability, or cause performance issues.
        </p>

        <p>
          This catalog provides detailed specifications for each smell, including:
        </p>
        <ul>
          <li><strong>What it detects:</strong> The specific patterns and code structures that trigger the smell</li>
          <li><strong>Why it matters:</strong> The impact on code quality, performance, or maintainability</li>
          <li><strong>How it's measured:</strong> The metrics and formulas used for detection</li>
          <li><strong>When it triggers:</strong> The thresholds that cause a report</li>
          <li><strong>How to fix it:</strong> Examples of problematic code and recommended solutions</li>
        </ul>

        <div class="note">
          <strong>Note:</strong> This catalog is aligned with the detector implementation (rules.pdf).
          All metrics, formulas, and thresholds match the actual behavior of the DeSmell tool.
        </div>
      </section>

      <div class="summary" id="catalog">
        <h2>Quick Reference Table</h2>
        <table aria-label="Smell Summary Table">
          <thead>
            <tr>
              <th>Smell</th>
              <th>Detector ID</th>
              <th>Primary Metric</th>
              <th>Threshold</th>
              <th>Category</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><strong>CFC</strong></td><td><code>ComposableFunctionComplexityIssue</code></td><td>Weighted complexity</td><td><code>CFC ≥ 25</code> or <code>loops &gt; 4</code></td><td><span class="chip chip-arch">Architecture</span></td></tr>
            <tr><td><strong>Constants in Composable</strong></td><td><code>ConstantsInComposable</code></td><td>Occurrence</td><td>Any occurrence</td><td><span class="chip chip-recomp">Recomposition</span></td></tr>
            <tr><td><strong>SED</strong></td><td><code>HighSideEffectDensityIssue</code></td><td><code>sideEffectCount/uiNodeCount</code></td><td><code>SED ≥ 0.30</code> and <code>sideEffectCount ≥ 2</code></td><td><span class="chip chip-recomp">Side-Effects</span></td></tr>
            <tr><td><strong>LIU</strong></td><td><code>LogicInUIIssue</code></td><td>Control-flow density</td><td><code>LIU &gt; 0.30</code></td><td><span class="chip chip-arch">Architecture</span></td></tr>
            <tr><td><strong>Multiple Flows</strong></td><td><code>MultipleFlowCollectionsPerComposable</code></td><td>Flow count</td><td><code>&gt; 2</code></td><td><span class="chip chip-arch">Architecture</span></td></tr>
            <tr><td><strong>MutableState in Conditions</strong></td><td><code>MutableStateInCondition</code></td><td>Occurrence</td><td>Any occurrence</td><td><span class="chip chip-recomp">Recomposition</span></td></tr>
            <tr><td><strong>State Mutation</strong></td><td><code>MutableStateMutationInComposable</code></td><td>Occurrence</td><td>Any occurrence</td><td><span class="chip chip-state">State</span></td></tr>
            <tr><td><strong>Non-Savable Type</strong></td><td><code>NonSavableRememberSaveable</code></td><td>Occurrence</td><td>Any occurrence</td><td><span class="chip chip-state">State</span></td></tr>
            <tr><td><strong>rememberUpdatedState</strong></td><td><code>RememberUpdatedStateWithConstant</code></td><td>Occurrence</td><td>Any occurrence</td><td><span class="chip chip-recomp">Recomposition</span></td></tr>
            <tr><td><strong>Reused Key</strong></td><td><code>ReusedKeyInNestedScope</code></td><td>Binary</td><td>Any nested reuse</td><td><span class="chip chip-recomp">Recomposition</span></td></tr>
            <tr><td><strong>SEC</strong></td><td><code>SideEffectComplexityIssue</code></td><td>Effect complexity</td><td><code>SEC ≥ 10</code></td><td><span class="chip chip-recomp">Side-Effects</span></td></tr>
            <tr><td><strong>Slot Count</strong></td><td><code>SlotCountInComposable</code></td><td>Slot count</td><td><code>&gt; 3</code></td><td><span class="chip chip-api">API Design</span></td></tr>
            <tr><td><strong>Reactive State Pass-Through</strong></td><td><code>ReactiveStatePassThrough</code></td><td>Pass-through chain length</td><td><code>chain ≥ 2</code></td><td><span class="chip chip-recomp">Recomposition</span></td></tr>
            <tr><td><strong>Non-Snapshot-Aware Collections in State</strong></td><td><code>NonSnapshotAwareCollectionInState</code></td><td>Occurrence</td><td>In-place mutation on state-held collection</td><td><span class="chip chip-recomp">Recomposition</span></td></tr>
          </tbody>
        </table>
      </div>

      <div class="category-header" id="smells">
        <h3>Smell Catalog</h3>
      </div>

      <!-- 1 -->
      <section id="cfc">
        <h2>1. Composable Function Complexity (CFC)</h2>
        <div class="meta">
          <span class="detector-id">ComposableFunctionComplexityIssue</span>
          <span class="chip chip-arch">Architectural Responsibility</span>
        </div>

        <p><strong>What it detects:</strong> Composables that have accumulated too much complexity, mixing UI rendering with business logic, side-effect orchestration, and data access. These composables act more like controllers than pure UI components.</p>

        <h3>Why it matters</h3>
        <p>High CFC indicates that a composable is doing too much. This makes the code harder to test, maintain, and reason about. It also increases the risk of unnecessary recompositions and makes it difficult to follow Compose's declarative principles.</p>

        <h3>What's measured</h3>
        <table class="kvs">
          <tr>
            <th>Metric</th>
            <th>Description</th>
          </tr>
          <tr>
            <td><strong>Branches</strong></td>
            <td>Count of <code>if</code>, <code>else-if</code>, and <code>when</code> entries (excluding <code>else</code>)</td>
          </tr>
          <tr>
            <td><strong>Loops</strong></td>
            <td>Imperative loops (<code>for</code>, <code>while</code>, <code>do-while</code>) and functional loops (<code>forEach</code>, <code>map</code>, <code>filter</code>, etc.)</td>
          </tr>
          <tr>
            <td><strong>maxDepth</strong></td>
            <td>Maximum nesting depth of control structures</td>
          </tr>
          <tr>
            <td><strong>SEC_total</strong></td>
            <td>Sum of Side-Effect Complexity scores from all effect blocks in the composable</td>
          </tr>
          <tr>
            <td><strong>SED</strong></td>
            <td>Number of side-effect blocks (LaunchedEffect, DisposableEffect, etc.)</td>
          </tr>
          <tr>
            <td><strong>parameters</strong></td>
            <td>Count of function parameters (excluding design-only params)</td>
          </tr>
          <tr>
            <td><strong>viewModelAccesses</strong></td>
            <td>Number of direct ViewModel property or method accesses</td>
          </tr>
        </table>

        <h3>Formula</h3>
        <div class="formula">
          CFC = 2×branches + 3×loops + 2×maxDepth + 1×SEC_total + 2×SED + 1×parameters + 3×viewModelAccesses
        </div>

        <h3>Thresholds</h3>
        <div class="threshold-box">
          <strong>Primary threshold:</strong> <code>CFC ≥ 25</code> (configurable via lint options)
          <br><strong>Hard rule:</strong> <code>loops &gt; 4</code> → always reported regardless of total CFC score
        </div>

        <h3>How to fix</h3>
        <ul>
          <li>Extract complex logic into separate functions or ViewModel methods</li>
          <li>Break large composables into smaller, focused components</li>
          <li>Move side-effect orchestration to ViewModel or use cases</li>
          <li>Reduce ViewModel accesses by passing only needed state as parameters</li>
          <li>Simplify control flow by using derived state or state machines</li>
        </ul>
      </section>

      <!-- 2 -->
      <section id="constants">
        <h2>2. Constants in Composable</h2>
        <div class="meta">
          <span class="detector-id">ConstantsInComposable</span>
          <span class="chip chip-recomp">Recomposition Efficiency</span>
        </div>

        <p><strong>What it detects:</strong> Immutable constant values declared directly inside a composable function body without being wrapped in <code>remember</code>.</p>

        <h3>Why it matters</h3>
        <p>Constants declared inside composables are recreated on every recomposition, causing unnecessary allocations. This wastes memory and CPU cycles. Constants should be hoisted outside the composable or wrapped in <code>remember</code> to avoid redundant reallocation.</p>

        <h3>What counts as a constant</h3>
        <ul>
          <li>Literals: <code>42</code>, <code>"Hello"</code>, <code>true</code></li>
          <li>Constant expressions: <code>2 + 3</code>, <code>10 * 5</code></li>
          <li>Extension functions: <code>16.dp</code>, <code>14.sp</code></li>
          <li>Immutable factory calls: <code>listOf(1, 2, 3)</code>, <code>mapOf("key" to "value")</code></li>
          <li>Constructor calls with constant arguments</li>
          <li>String templates without interpolation: <code>"Hello ${"World"}"</code></li>
        </ul>

        <h3>Examples</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">@Composable
fun MyScreen() {
    val padding = 16.dp  // ❌ Recreated on every recomposition
    val colors = listOf(Color.Red, Color.Blue)  // ❌ New list allocated each time
    
    Column(modifier = Modifier.padding(padding)) {
        // ...
    }
}</div>
        </div>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">// Option 1: Hoist to top level
private val SCREEN_PADDING = 16.dp
private val SCREEN_COLORS = listOf(Color.Red, Color.Blue)

@Composable
fun MyScreen() {
    Column(modifier = Modifier.padding(SCREEN_PADDING)) {
        // ...
    }
}

// Option 2: Use remember
@Composable
fun MyScreen() {
    val padding = remember { 16.dp }
    val colors = remember { listOf(Color.Red, Color.Blue) }
    
    Column(modifier = Modifier.padding(padding)) {
        // ...
    }
}</div>
        </div>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Zero tolerance:</strong> Any constant declaration inside a composable (not in <code>remember</code>) is reported.
        </div>

        <div class="note">
          <strong>Note:</strong> <code>var</code> declarations are excluded, as they're expected to change. Constants inside <code>remember { }</code> blocks are also excluded.
        </div>
      </section>

      <!-- 3 -->
      <section id="sed">
        <h2>3. High Side-Effect Density (SED)</h2>
        <div class="meta">
          <span class="detector-id">HighSideEffectDensityIssue</span>
          <span class="chip chip-recomp">Side-Effect Orchestration</span>
        </div>

        <p><strong>What it detects:</strong> Composables where side-effects (lifecycle management, reactive coordination) dominate the UI rendering code, suggesting misplaced coordination logic.</p>

        <h3>Why it matters</h3>
        <p>When a composable has too many side-effects relative to its UI code, it's likely performing coordination logic that belongs in a ViewModel or controller. This makes the composable harder to test and violates separation of concerns.</p>

        <h3>What's counted</h3>
        <p><strong>Side-effects:</strong></p>
        <ul>
          <li><code>LaunchedEffect</code>, <code>DisposableEffect</code>, <code>SideEffect</code></li>
          <li><code>produceState</code>, <code>produceRetainedState</code></li>
          <li>Restartable effects and effect-like constructs</li>
        </ul>

        <p><strong>UI nodes:</strong> The number of composable UI calls (render-layer composable invocations like <code>Text</code>, <code>Button</code>, <code>Column</code>, etc.), not raw statement count.</p>

        <h3>Formula</h3>
        <div class="formula">
          SED = sideEffectCount / uiNodeCount
        </div>

        <h3>Thresholds</h3>
        <div class="threshold-box">
          <strong>Both conditions must be met:</strong>
          <ul style="margin:8px 0 0 0; padding-left:20px">
            <li><code>sideEffectCount ≥ 2</code></li>
            <li><code>SED ≥ 0.30</code> (30% of the composable is side-effects)</li>
          </ul>
        </div>

        <h3>Additional diagnostics</h3>
        <p>The detector also reports when:</p>
        <ul>
          <li>Duplicate <code>LaunchedEffect</code> keys are detected (suggesting consolidation)</li>
          <li>Multiple effects share dependencies and could be merged</li>
        </ul>

        <h3>How to fix</h3>
        <ul>
          <li>Move coordination logic to ViewModel</li>
          <li>Consolidate multiple effects with shared dependencies</li>
          <li>Extract side-effect logic into custom composables or hooks</li>
          <li>Use state hoisting to reduce the need for multiple effects</li>
        </ul>
      </section>

      <!-- 4 -->
      <section id="liu">
        <h2>4. Logic in UI Density (LIU)</h2>
        <div class="meta">
          <span class="detector-id">LogicInUIIssue</span>
          <span class="chip chip-arch">Architectural Responsibility</span>
        </div>

        <p><strong>What it detects:</strong> Composables where imperative control flow (if/when/loops) dominates the code, indicating business logic leakage into the UI layer.</p>

        <h3>Why it matters</h3>
        <p>Composables should map state to UI declaratively. When they contain too much imperative decision-making, it suggests business logic has leaked into the presentation layer, making the code harder to test and maintain.</p>

        <h3>What's counted</h3>
        <p><strong>Control flow constructs:</strong></p>
        <ul>
          <li><code>if</code>, <code>else-if</code></li>
          <li><code>when</code> entries (excluding <code>else</code>)</li>
          <li>Loops: <code>for</code>, <code>while</code>, <code>do-while</code>, and functional loops</li>
          <li><code>break</code>, <code>continue</code>, <code>throw</code></li>
          <li><code>try</code> / <code>catch</code> / <code>finally</code></li>
        </ul>

        <h3>Weighting</h3>
        <p>Control flow is weighted differently based on context:</p>
        <ul>
          <li><strong>Render control flow</strong> (directly shaping UI structure): weight <code>1.0</code></li>
          <li><strong>Behavioral control flow</strong> (inside callbacks/modifiers): weight <code>0.5</code></li>
        </ul>

        <h3>Formula</h3>
        <div class="formula">
          LIU = (CF_render + 0.5×CF_behavior) / totalStatements
        </div>

        <h3>Guards</h3>
        <p>The detector skips analysis if:</p>
        <ul>
          <li><code>totalStatements &lt; 5</code> (too small to be meaningful)</li>
          <li><code>controlFlowCount &lt; 2</code> (not enough control flow)</li>
          <li><code>controlFlowCount &gt; 6</code> (already obviously a controller - avoid noise)</li>
        </ul>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Report when:</strong> <code>LIU &gt; 0.30</code> (30% of statements are control flow) with guards above.
        </div>

        <h3>How to fix</h3>
        <ul>
          <li>Move business logic to ViewModel or use cases</li>
          <li>Use derived state to precompute decisions</li>
          <li>Extract complex conditional rendering into separate composables</li>
          <li>Use state machines or sealed classes to model UI state</li>
        </ul>
      </section>

      <!-- 5 -->
      <section id="multi-flow">
        <h2>5. Multiple Flow Collections per Composable</h2>
        <div class="meta">
          <span class="detector-id">MultipleFlowCollectionsPerComposable</span>
          <span class="chip chip-arch">Architectural Responsibility</span>
        </div>

        <p><strong>What it detects:</strong> Composables that collect too many independent reactive streams (Flows), increasing recomposition frequency and coupling to state management.</p>

        <h3>Why it matters</h3>
        <p>Each Flow collection creates a separate recomposition trigger. Multiple independent flows mean the composable can recompose frequently and unpredictably. This also suggests missing state aggregation at the ViewModel layer.</p>

        <h3>What counts</h3>
        <p>Distinct invocations of:</p>
        <ul>
          <li><code>collectAsState()</code></li>
          <li><code>collectAsStateWithLifecycle()</code></li>
        </ul>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Maximum allowed:</strong> 2 flow collections per composable
          <br>Report when: <code>flowCollectionCount &gt; 2</code>
        </div>

        <h3>Examples</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">@Composable
fun MyScreen(viewModel: MyViewModel) {
    val uiState = viewModel.uiState.collectAsStateWithLifecycle()
    val loadingState = viewModel.loadingState.collectAsStateWithLifecycle()
    val errorState = viewModel.errorState.collectAsStateWithLifecycle()  // ❌ 3 flows
    
    // ...
}</div>
        </div>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">// Aggregate state in ViewModel
data class MyUiState(
    val content: String,
    val isLoading: Boolean,
    val error: String?
)

@Composable
fun MyScreen(viewModel: MyViewModel) {
    val uiState = viewModel.uiState.collectAsStateWithLifecycle()  // ✅ Single aggregated state
    
    // ...
}</div>
        </div>

        <h3>How to fix</h3>
        <ul>
          <li>Aggregate multiple flows into a single state class in the ViewModel</li>
          <li>Use <code>combine</code> or <code>flowOf</code> to merge related flows</li>
          <li>Extract some flow collections into child composables</li>
          <li>Consider using a state holder pattern to manage related state</li>
        </ul>
      </section>

      <!-- 6 -->
      <section id="ms-cond">
        <h2>6. MutableState in Boolean Conditions</h2>
        <div class="meta">
          <span class="detector-id">MutableStateInCondition</span>
          <span class="chip chip-recomp">Recomposition Efficiency</span>
        </div>

        <p><strong>What it detects:</strong> Reading <code>MutableState.value</code> directly inside boolean or comparison expressions (if conditions, when subjects, comparisons).</p>

        <h3>Why it matters</h3>
        <p>Reading mutable state inside conditions causes unnecessary recompositions. The condition is re-evaluated on every recomposition, even when the state hasn't changed in a way that affects the condition's result. Using derived state makes the recomposition behavior more predictable and efficient.</p>

        <h3>Flagged examples</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">@Composable
fun MyScreen() {
    val count = remember { mutableStateOf(0) }
    
    if (count.value > 3) {  // ❌ Reading .value in condition
        Text("High count")
    }
    
    when (count.value) {  // ❌ Reading .value in when
        0 -> Text("Zero")
        else -> Text("Non-zero")
    }
}</div>
        </div>

        <h3>Allowed patterns</h3>
        <ul>
          <li><code>if (myBooleanState)</code> when the type is <code>MutableState&lt;Boolean&gt;</code> (direct boolean state)</li>
          <li><code>when</code> over enums (stable values)</li>
          <li>Use of <code>derivedStateOf</code> to precompute the condition</li>
        </ul>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">@Composable
fun MyScreen() {
    val count = remember { mutableStateOf(0) }
    val isHighCount = remember { 
        derivedStateOf { count.value > 3 } 
    }  // ✅ Derived state
    
    if (isHighCount.value) {
        Text("High count")
    }
    
    // Or use the state directly if it's boolean
    val isEnabled = remember { mutableStateOf(true) }
    if (isEnabled.value) {  // ✅ OK for boolean state
        // ...
    }
}</div>
        </div>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Per occurrence:</strong> Any detected usage is reported immediately.
        </div>
      </section>

      <!-- 7 -->
      <section id="ms-mutation">
        <h2>7. MutableState Mutation in Composable</h2>
        <div class="meta">
          <span class="detector-id">MutableStateMutationInComposable</span>
          <span class="chip chip-state">State Management</span>
        </div>

        <p><strong>What it detects:</strong> Direct mutation of state during composition (not inside callbacks or effects).</p>

        <h3>Why it matters</h3>
        <p>Composables should be idempotent - calling them with the same inputs should produce the same result. Mutating state during composition violates this principle and can cause feedback loops, infinite recompositions, and unpredictable behavior.</p>

        <h3>Flagged patterns</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">@Composable
fun MyScreen() {
    val count = remember { mutableStateOf(0) }
    
    count.value = 5  // ❌ Mutation during composition
    
    var localState by remember { mutableStateOf(0) }
    localState = 10  // ❌ Mutation during composition
    
    Text("Count: $count")
}</div>
        </div>

        <h3>Allowed patterns</h3>
        <p>Mutations are allowed (and expected) in:</p>
        <ul>
          <li>Callbacks: <code>onClick</code>, <code>onTextChanged</code>, etc.</li>
          <li>Side-effect blocks: <code>LaunchedEffect</code>, <code>DisposableEffect</code>, etc.</li>
        </ul>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">@Composable
fun MyScreen() {
    val count = remember { mutableStateOf(0) }
    
    Button(onClick = { count.value++ }) {  // ✅ Mutation in callback
        Text("Increment")
    }
    
    LaunchedEffect(Unit) {
        count.value = 10  // ✅ Mutation in effect
    }
    
    Text("Count: ${count.value}")
}</div>
        </div>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Per occurrence:</strong> Any mutation outside callbacks or effects is reported.
        </div>

        <h3>How to fix</h3>
        <ul>
          <li>Move state mutations to event handlers (onClick, etc.)</li>
          <li>If initialization is needed, use <code>LaunchedEffect</code> or <code>DisposableEffect</code></li>
          <li>Use state hoisting to manage state in a parent composable or ViewModel</li>
        </ul>
      </section>

      <!-- 8 -->
      <section id="remember-saveable">
        <h2>8. Non-Savable Type in rememberSaveable</h2>
        <div class="meta">
          <span class="detector-id">NonSavableRememberSaveable</span>
          <span class="chip chip-state">State Restoration</span>
        </div>

        <p><strong>What it detects:</strong> Using <code>rememberSaveable</code> with types that cannot be persisted through Android's Bundle/state restoration mechanism without a custom <code>Saver</code>.</p>

        <h3>Why it matters</h3>
        <p>If a non-savable type is used with <code>rememberSaveable</code> without a custom saver, state restoration will silently fail. The state will be lost when the activity is recreated (e.g., on configuration change or process death).</p>

        <h3>Savable types (no custom saver needed)</h3>
        <ul>
          <li>Primitives: <code>Int</code>, <code>Boolean</code>, <code>String</code>, <code>Float</code>, etc.</li>
          <li><code>String</code></li>
          <li>Enums</li>
          <li><code>Parcelable</code> types</li>
          <li><code>Serializable</code> types</li>
          <li>Types annotated with <code>@Serializable</code> (Kotlinx Serialization)</li>
        </ul>

        <h3>Examples</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">data class User(val name: String, val age: Int)  // Not Parcelable or Serializable

@Composable
fun MyScreen() {
    val user = rememberSaveable { User("John", 30) }  // ❌ Non-savable type
    
    // State will be lost on configuration change!
}</div>
        </div>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">// Option 1: Make it Parcelable
@Parcelize
data class User(val name: String, val age: Int) : Parcelable

@Composable
fun MyScreen() {
    val user = rememberSaveable { User("John", 30) }  // ✅ Now savable
}

// Option 2: Use a custom Saver
@Composable
fun MyScreen() {
    val user = rememberSaveable(
        saver = Saver(
            save = { "${it.name}|${it.age}" },
            restore = { 
                it.split("|").let { parts -> 
                    User(parts[0], parts[1].toInt()) 
                } 
            }
        )
    ) { User("John", 30) }  // ✅ Custom saver provided
}</div>
        </div>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Per occurrence:</strong> Any non-savable usage without a custom saver is reported.
        </div>
      </section>

      <!-- 9 -->
      <section id="rus-constant">
        <h2>9. rememberUpdatedState with Constant</h2>
        <div class="meta">
          <span class="detector-id">RememberUpdatedStateWithConstant</span>
          <span class="chip chip-recomp">Recomposition Efficiency</span>
        </div>

        <p><strong>What it detects:</strong> Using <code>rememberUpdatedState</code> to wrap a constant or immutable value that never changes.</p>

        <h3>Why it matters</h3>
        <p><code>rememberUpdatedState</code> is designed for values that change across recompositions (like callbacks). Using it with constants misrepresents mutability, introduces unnecessary snapshot reads, and obscures the code's intent.</p>

        <h3>What counts as constant</h3>
        <ul>
          <li>Literals: <code>42</code>, <code>"Hello"</code></li>
          <li>Immutable factory calls: <code>listOf(1, 2, 3)</code></li>
          <li><code>const val</code> declarations</li>
          <li>Stable function references: <code>::myFunction</code></li>
          <li>Parameters proven constant across call sites</li>
        </ul>

        <h3>Examples</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">@Composable
fun MyScreen() {
    val constantValue = rememberUpdatedState(42)  // ❌ Constant value
    val constantList = rememberUpdatedState(listOf(1, 2, 3))  // ❌ Immutable list
    
    // Use regular remember or hoist instead
}</div>
        </div>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">@Composable
fun MyScreen(onClick: () -> Unit) {
    // ✅ Use rememberUpdatedState for changing callbacks
    val currentOnClick = rememberUpdatedState(onClick)
    
    LaunchedEffect(Unit) {
        // currentOnClick.value will always reference the latest onClick
        // even if the composable recomposes with a new onClick
    }
    
    // ✅ Use remember for constants
    val constantValue = remember { 42 }
    
    // ✅ Or hoist to top level
    // private val CONSTANT_VALUE = 42
}</div>
        </div>

        <h3>Exclusions</h3>
        <p>Lambdas/callbacks that are expected to change across recompositions are excluded, as <code>rememberUpdatedState</code> is the correct choice for these.</p>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Per occurrence:</strong> Any qualifying usage is reported.
        </div>
      </section>

      <!-- 10 -->
      <section id="reused-key">
        <h2>10. Reused Key in Nested Scope</h2>
        <div class="meta">
          <span class="detector-id">ReusedKeyInNestedScope</span>
          <span class="chip chip-recomp">Recomposition Semantics</span>
        </div>

        <p><strong>What it detects:</strong> The same key expression being reused redundantly across nested recomposition or effect scopes (parent → child, or passed as parameter and reused).</p>

        <h3>Why it matters</h3>
        <p>When a parent scope already uses a key, reusing the same key in a nested child scope is redundant. Child scopes are already invalidated when parent keys change, so the nested key adds no value and obscures recomposition boundaries.</p>

        <h3>Targeted APIs</h3>
        <ul>
          <li><code>key(...)</code></li>
          <li><code>LaunchedEffect(...)</code></li>
          <li><code>DisposableEffect(...)</code></li>
          <li><code>produceState(...)</code></li>
        </ul>

        <h3>Detection logic</h3>
        <ol>
          <li>Extract key expressions (non-lambda arguments) from all scopes</li>
          <li>Traverse ancestor scopes: if a parent key intersects with the current key → violation</li>
          <li>Inter-procedural check: detect when a parent key variable is passed to a child composable and reused as a key deeper in the call tree</li>
        </ol>

        <h3>Examples</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">@Composable
fun ParentScreen(userId: String) {
    key(userId) {  // Parent key
        LaunchedEffect(userId) {  // ❌ Redundant - already keyed by parent
            // ...
        }
        
        ChildComposable(userId)  // If this also uses userId as key, violation
    }
}

@Composable
fun ChildComposable(userId: String) {
    key(userId) {  // ❌ Redundant if parent already keyed by userId
        // ...
    }
}</div>
        </div>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">@Composable
fun ParentScreen(userId: String) {
    key(userId) {  // Parent key
        LaunchedEffect(Unit) {  // ✅ No redundant key
            // Use userId directly - already scoped by parent key
        }
        
        ChildComposable(userId)  // Pass as parameter, no key needed
    }
}

@Composable
fun ChildComposable(userId: String) {
    // ✅ No key needed - already scoped by parent
    Text("User: $userId")
}</div>
        </div>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Binary detection:</strong> Any repeated key reuse across nested scopes is reported. First violation is reported to avoid noise.
        </div>
      </section>

      <!-- 11 -->
      <section id="sec">
        <h2>11. Side-Effect Complexity (SEC)</h2>
        <div class="meta">
          <span class="detector-id">SideEffectComplexityIssue</span>
          <span class="chip chip-recomp">Side-Effect Orchestration</span>
        </div>

        <p><strong>What it detects:</strong> Side-effect blocks (LaunchedEffect, DisposableEffect, etc.) whose internal complexity indicates misuse of effect APIs for business or orchestration logic.</p>

        <h3>Why it matters</h3>
        <p>Side-effects should be simple lifecycle hooks. When they contain complex logic, it harms testability, obscures lifecycle semantics, and increases recomposition unpredictability. Complex logic belongs in ViewModels or use cases.</p>

        <p><strong>Note:</strong> SEC is also used as a component metric in CFC calculation.</p>

        <h3>Side-effects analyzed</h3>
        <ul>
          <li><code>LaunchedEffect</code>, <code>DisposableEffect</code>, <code>SideEffect</code></li>
          <li><code>produceState</code>, <code>produceRetainedState</code></li>
          <li>Restartable nested launches/async inside effects</li>
        </ul>

        <h3>Metrics collected (inside effect lambda)</h3>
        <table class="kvs">
          <tr>
            <th>Metric</th>
            <th>Description</th>
          </tr>
          <tr>
            <td><strong>branches</strong></td>
            <td>Count of <code>if</code> and <code>when</code> statements</td>
          </tr>
          <tr>
            <td><strong>loops</strong></td>
            <td>Count of <code>for</code>, <code>while</code>, <code>do-while</code> loops</td>
          </tr>
          <tr>
            <td><strong>maxDepth</strong></td>
            <td>Maximum nesting depth of control structures</td>
          </tr>
          <tr>
            <td><strong>launchedScopes</strong></td>
            <td>Nested <code>launch</code>, <code>async</code>, or restartable scopes</td>
          </tr>
          <tr>
            <td><strong>statements</strong></td>
            <td>Approximate size via recursive statement counting</td>
          </tr>
        </table>

        <h3>Formula</h3>
        <div class="formula">
          SEC = 2×branches + 3×loops + 2×maxDepth + 3×launchedScopes + floor(statements/10)
        </div>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Report when:</strong> <code>SEC ≥ 10</code>
        </div>

        <h3>Examples</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">@Composable
fun MyScreen(viewModel: MyViewModel) {
    LaunchedEffect(Unit) {
        // ❌ Complex business logic in effect
        var retries = 0
        while (retries < 3) {
            try {
                if (viewModel.shouldFetch()) {
                    val data = viewModel.fetchData()
                    if (data.isNotEmpty()) {
                        viewModel.processData(data)
                        for (item in data) {
                            viewModel.validateItem(item)
                        }
                    }
                }
                break
            } catch (e: Exception) {
                retries++
            }
        }
    }
}</div>
        </div>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">@Composable
fun MyScreen(viewModel: MyViewModel) {
    // ✅ Move complex logic to ViewModel
    LaunchedEffect(Unit) {
        viewModel.initialize()  // Simple call to ViewModel method
    }
}

// In ViewModel:
class MyViewModel {
    suspend fun initialize() {
        // Complex logic here - testable, reusable
        var retries = 0
        while (retries < 3) {
            // ...
        }
    }
}</div>
        </div>

        <h3>Reporting scope</h3>
        <p>Reported on the specific side-effect call site (not the composable), with a full metric breakdown showing branches, loops, depth, launchedScopes, and statements.</p>
      </section>

      <!-- 12 -->
      <section id="slot-count">
        <h2>12. Slot Count in Composable</h2>
        <div class="meta">
          <span class="detector-id">SlotCountInComposable</span>
          <span class="chip chip-api">API Design</span>
        </div>

        <p><strong>What it detects:</strong> Composables that expose too many composable lambda parameters ("slots"), increasing cognitive load and reducing API discoverability.</p>

        <h3>Why it matters</h3>
        <p>While not a runtime correctness issue, excessive slots make composable APIs harder to understand and use. It suggests the component should be decomposed into smaller, more focused composables.</p>

        <h3>What counts as a slot</h3>
        <p>A parameter counts as a slot if:</p>
        <ol>
          <li>It is a function/lambda type, <strong>and</strong></li>
          <li>It is annotated with <code>@Composable</code></li>
        </ol>

        <h3>Examples</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">@Composable
fun ComplexCard(
    header: @Composable () -> Unit,        // Slot 1
    title: @Composable () -> Unit,         // Slot 2
    subtitle: @Composable () -> Unit,      // Slot 3
    content: @Composable () -> Unit,       // Slot 4 ❌
    footer: @Composable () -> Unit,        // Slot 5 ❌
    actions: @Composable RowScope.() -> Unit // Slot 6 ❌
) {
    // Too many slots - hard to remember and use
}</div>
        </div>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">// Option 1: Reduce slots by grouping
@Composable
fun Card(
    header: @Composable () -> Unit,  // Slot 1
    content: @Composable () -> Unit,  // Slot 2
    footer: @Composable () -> Unit    // Slot 3 ✅
) {
    // ...
}

// Option 2: Use a data class for related slots
data class CardHeader(
    val title: String,
    val subtitle: String
)

@Composable
fun Card(
    header: CardHeader,                // Not a slot
    content: @Composable () -> Unit,   // Slot 1
    actions: @Composable () -> Unit     // Slot 2 ✅
) {
    // ...
}</div>
        </div>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Maximum allowed:</strong> 3 slots per composable
          <br>Report when: <code>slotCount &gt; 3</code> (configurable per-project)
        </div>

        <h3>Severity</h3>
        <p><span class="badge badge-low">Low-Medium</span> - This is an API design smell, not a runtime correctness defect. The code will work, but the API may be harder to use.</p>

        <h3>How to fix</h3>
        <ul>
          <li>Group related slots into data classes or sealed classes</li>
          <li>Extract some slots into separate composable parameters (non-composable)</li>
          <li>Break the composable into smaller components</li>
          <li>Use builder pattern or DSL for complex configurations</li>
        </ul>
      </section>

      <!-- 13 -->
      <section id="reactive-pass-through">
        <h2>13. Reactive State Pass-Through</h2>
        <div class="meta">
          <span class="detector-id">ReactiveStatePassThrough</span>
          <span class="chip chip-recomp">Recomposition Efficiency &amp; State Handling</span>
        </div>

        <p><strong>What it detects:</strong> Composables that receive reactive state (or values derived from reactive state) as parameters but do not consume or transform them—only passing them unchanged to a single child. The detector reports only when the same parameter is passed through <strong>at least two consecutive</strong> composable layers without being used (a chain of ≥ 2 pass-throughs).</p>

        <h3>Why it matters</h3>
        <p>Passing reactive objects (<code>State&lt;T&gt;</code>, <code>Flow&lt;T&gt;</code>, <code>StateFlow&lt;T&gt;</code>, etc.) or state-derived values through multiple intermediate composables without use increases recomposition scope, violates proper state ownership, and makes the data flow harder to reason about. State should be collected or consumed closer to where it is used, or passed as immutable snapshots.</p>

        <h3>Reactive types considered</h3>
        <p>The detector treats the following parameter types as reactive state:</p>
        <table class="kvs">
          <tr>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr><td><code>State&lt;T&gt;</code> / <code>MutableState&lt;T&gt;</code></td><td>Compose runtime state</td></tr>
          <tr><td><code>StateFlow&lt;T&gt;</code> / <code>MutableStateFlow&lt;T&gt;</code></td><td>Kotlin Flow hot stream</td></tr>
          <tr><td><code>Flow&lt;T&gt;</code></td><td>Kotlin Flow cold stream</td></tr>
          <tr><td><code>LiveData&lt;T&gt;</code></td><td>Android LiveData</td></tr>
          <tr><td>Values from <code>mutableStateOf</code></td><td>e.g. <code>var x by remember { mutableStateOf(0) }</code> passed as <code>Int</code></td></tr>
          <tr><td>Values from <code>collectAsState</code> / <code>collectAsStateWithLifecycle</code></td><td>Collected <code>State&lt;T&gt;</code> passed to children</td></tr>
        </table>

        <h3>Pass-through vs consumption</h3>
        <table class="kvs">
          <tr>
            <th>Pass-through (not used)</th>
            <th>Consumption (used)</th>
          </tr>
          <tr>
            <td>Parameter only passed as a direct argument to one child composable</td>
            <td>Parameter used in any other way: <code>.value</code>, <code>.toString()</code>, <code>.let { }</code>, <code>collectAsState</code>, string interpolation, property access, etc.</td>
          </tr>
        </table>

        <h3>Chain rule</h3>
        <div class="threshold-box">
          <strong>Report when:</strong> There is a chain of <strong>≥ 2</strong> consecutive composables that each pass the same reactive parameter through to a single child without consuming it. A single pass-through (chain of 1) is not reported.
        </div>

        <h3>Origin and secondary locations</h3>
        <p>When the reactive state originates from a local variable (e.g. <code>mutableStateOf</code>, <code>collectAsState</code>, <code>collectAsStateWithLifecycle</code>), the report can include a secondary location pointing to the creation point (e.g. <code>val state = flow.collectAsState(...)</code>) to help locate where the state was introduced.</p>

        <h3>Examples</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">@Composable
fun LayerA(flow: Flow&lt;UiState&gt;) {
    LayerB(flow)  // Pass-through
}

@Composable
fun LayerB(flow: Flow&lt;UiState&gt;) {
    LayerC(flow)  // Pass-through
}

@Composable
fun LayerC(flow: Flow&lt;UiState&gt;) {
    val state = flow.collectAsState(UiState(""))  // Only LayerC consumes
    Text(state.value.title)
}
// LayerA and LayerB are flagged: chain of 2 pass-throughs</div>
        </div>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">// Option 1: Collect at the top, pass State through one layer (chain of 1 — not reported)
@Composable
fun Parent(stateFlow: StateFlow&lt;UiState&gt;) {
    val state = stateFlow.collectAsState(UiState(""))
    Child(state)  // Single pass-through OK
}

@Composable
fun Child(state: State&lt;UiState&gt;) {
    Text(state.value.title)
}

// Option 2: Collect close to usage
@Composable
fun LayerA(flow: Flow&lt;UiState&gt;) {
    val state = flow.collectAsState(UiState(""))  // Consumed here
    LayerB(state)  // Pass immutable snapshot or derived state if needed
}</div>
        </div>

        <h3>How to fix</h3>
        <ul>
          <li>Move state collection (<code>collectAsState</code>, <code>collectAsStateWithLifecycle</code>) closer to the composable that actually uses the state</li>
          <li>Pass immutable snapshots (e.g. <code>state.value</code>) instead of the reactive object when only a snapshot is needed downstream</li>
          <li>Derive specific state (e.g. <code>derivedStateOf</code>) at the layer that needs it instead of passing the full reactive object through</li>
          <li>Eliminate unnecessary intermediate composables that only forward the parameter</li>
        </ul>
      </section>

      <!-- 14 -->
      <section id="non-snapshot-collection">
        <h2>14. Non-Snapshot-Aware Collections in State</h2>
        <div class="meta">
          <span class="detector-id">NonSnapshotAwareCollectionInState</span>
          <span class="chip chip-recomp">Recomposition Efficiency &amp; State Handling</span>
        </div>

        <p><strong>What it detects:</strong> Standard Kotlin collections (<code>MutableList</code>, <code>List</code>, <code>Map</code>, <code>MutableMap</code>, <code>Set</code>, <code>MutableSet</code>, <code>ArrayList</code>, <code>HashMap</code>, <code>HashSet</code>) stored inside Compose state (<code>mutableStateOf</code>, <code>remember { mutableStateOf(...) }</code>) and then mutated in-place (e.g. <code>.add()</code>, <code>.remove()</code>, <code>.put()</code>, <code>.clear()</code>). Also detects when such state is passed as a composable parameter and mutated in-place in the receiving composable.</p>

        <h3>Why it matters</h3>
        <p>Compose's snapshot system observes the <em>state holder</em> (the reference), not internal mutations inside non-snapshot collections. Mutating the contents of a list or map stored in state (e.g. <code>items.value.add(1)</code>) does not trigger recomposition, so the UI will not update. Snapshot-aware collections (<code>mutableStateListOf()</code>, <code>mutableStateMapOf()</code>) or reassigning a new collection (<code>state.value = state.value + newItem</code>) are observed and trigger recomposition correctly.</p>

        <h3>What counts as non-snapshot collection state</h3>
        <ul>
          <li>State created with <code>mutableStateOf(mutableListOf(...))</code>, <code>mutableStateOf(arrayListOf(...))</code>, <code>mutableStateOf(mutableMapOf(...))</code>, <code>mutableStateOf(mutableSetOf(...))</code>, etc.</li>
          <li>Delegated state: <code>var items by remember { mutableStateOf(mutableListOf(...)) }</code> — mutations like <code>items.add(...)</code> are flagged.</li>
          <li>Parameters of type <code>MutableState&lt;List&lt;T&gt;&gt;</code>, <code>MutableState&lt;MutableList&lt;T&gt;&gt;</code>, <code>MutableState&lt;Map&lt;K,V&gt;&gt;</code>, etc. — in-place mutation in the receiving composable is flagged.</li>
        </ul>

        <h3>Excluded (not reported)</h3>
        <ul>
          <li><code>mutableStateListOf()</code>, <code>mutableStateMapOf()</code> — snapshot-aware; in-place mutations are observed.</li>
          <li>Reassignment instead of mutation: <code>items.value = items.value + 3</code> or <code>items.value = items.value.toMutableList().apply { add(x) }</code>.</li>
        </ul>

        <h3>Mutation methods that trigger a report</h3>
        <p><strong>List/MutableList:</strong> <code>add</code>, <code>addAll</code>, <code>remove</code>, <code>removeAll</code>, <code>removeAt</code>, <code>clear</code>, <code>retainAll</code>, <code>set</code>, <code>sort</code>, <code>shuffle</code>, <code>replaceAll</code></p>
        <p><strong>Map/MutableMap:</strong> <code>put</code>, <code>putAll</code>, <code>remove</code>, <code>clear</code>, <code>replace</code>, <code>compute</code>, <code>computeIfAbsent</code>, <code>computeIfPresent</code>, <code>merge</code></p>
        <p><strong>Set/MutableSet:</strong> <code>add</code>, <code>addAll</code>, <code>remove</code>, <code>removeAll</code>, <code>clear</code>, <code>retainAll</code></p>

        <h3>Examples</h3>
        <div class="code-block">
          <span class="example-label">❌ Bad</span>
          <div class="code bad-example">@Composable
fun Screen() {
    val items = remember { mutableStateOf(mutableListOf&lt;Int&gt;()) }
    items.value.add(1)  // ❌ In-place mutation — no recomposition
}

@Composable
fun Child(items: MutableState&lt;MutableList&lt;Int&gt;&gt;) {
    LaunchedEffect(Unit) {
        items.value.add(2)  // ❌ Same issue when state is passed as parameter
    }
}</div>
        </div>

        <div class="code-block">
          <span class="example-label">✅ Good</span>
          <div class="code good-example">@Composable
fun Screen() {
    val items = remember { mutableStateListOf&lt;Int&gt;() }  // ✅ Snapshot-aware
    items.add(1)  // ✅ Triggers recomposition
}

// Or use reassignment instead of mutation
@Composable
fun Screen() {
    val items = remember { mutableStateOf(listOf(1, 2)) }
    items.value = items.value + 3  // ✅ Reassignment — triggers recomposition
}</div>
        </div>

        <h3>Threshold</h3>
        <div class="threshold-box">
          <strong>Per occurrence:</strong> Any in-place mutation of a non-snapshot collection stored in state (or passed as parameter) is reported at the mutation call site.
        </div>

        <h3>How to fix</h3>
        <ul>
          <li>Use <code>mutableStateListOf()</code> or <code>mutableStateMapOf()</code> for list/map state that you need to mutate in-place.</li>
          <li>Or keep <code>mutableStateOf(listOf(...))</code> and update by reassignment: <code>state.value = state.value + newItem</code> or <code>state.value = state.value.toMutableList().apply { add(x) }</code>.</li>
          <li>When passing state to child composables, ensure the child does not mutate the collection in-place; use snapshot-aware types or reassignment in the child as well.</li>
        </ul>
      </section>

      <section id="appendix-metrics">
        <h2>Appendix: Metric Definitions</h2>
        <p>Quick reference for all metrics used across the smell detectors.</p>
        
        <table class="kvs">
          <tr>
            <th>Metric</th>
            <th>Definition</th>
          </tr>
          <tr>
            <td><strong>branches</strong></td>
            <td>Count of conditional branch points (<code>if</code>/<code>else-if</code>, and <code>when</code> entries excluding <code>else</code>).</td>
          </tr>
          <tr>
            <td><strong>loops</strong></td>
            <td>Count of loop constructs; includes imperative loops (<code>for</code>, <code>while</code>, <code>do-while</code>) and selected functional iteration calls (e.g., <code>forEach</code>, <code>map</code>, <code>filter</code>).</td>
          </tr>
          <tr>
            <td><strong>maxDepth</strong></td>
            <td>Maximum nesting depth of control structures (branches/loops/try-catch) within the analyzed scope.</td>
          </tr>
          <tr>
            <td><strong>sideEffectCount</strong></td>
            <td>Number of side-effect blocks detected inside a composable (e.g., <code>LaunchedEffect</code>, <code>DisposableEffect</code>, <code>SideEffect</code>, <code>produceState</code>, etc.).</td>
          </tr>
          <tr>
            <td><strong>uiNodeCount</strong></td>
            <td>Number of composable UI calls used to render UI (render-layer composable invocations like <code>Text</code>, <code>Button</code>, <code>Column</code>). Used by SED metric. <strong>Note:</strong> This is not raw statement count.</td>
          </tr>
          <tr>
            <td><strong>SEC_total</strong></td>
            <td>Sum of SEC (Side-Effect Complexity) values across all side-effect blocks in a composable. Used as an input to CFC calculation.</td>
          </tr>
          <tr>
            <td><strong>viewModelAccesses</strong></td>
            <td>Count of ViewModel access expressions inside the composable (e.g., direct property reads like <code>viewModel.state</code> or method calls like <code>viewModel.loadData()</code>).</td>
          </tr>
          <tr>
            <td><strong>controlFlowCount</strong></td>
            <td>Total count of control flow constructs (branches + loops + break/continue/throw + try/catch). Used in LIU calculation.</td>
          </tr>
          <tr>
            <td><strong>totalStatements</strong></td>
            <td>Approximate count of statements in the composable body. Used in LIU density calculation.</td>
          </tr>
        </table>

        <footer>
          <p>
            <strong>Documentation Note:</strong> This catalog is maintained alongside the detector implementation.
            If you modify detector logic (e.g., redefining <code>uiNodeCount</code> or adjusting thresholds),
            please update this catalog to keep the documentation and implementation in sync.
          </p>
        </footer>
      </section>
    </main>
  </div>
</div>
</body>
</html>

